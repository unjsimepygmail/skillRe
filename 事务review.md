# 数据库隔离特性
> + A 原子性：事务中操作要么全部执行成功，要么全都不执行成功
> + c 一致性：事务执行前后总数据要保持一致 
> + I 隔离性：一个事务无法干扰另外一个事务
> + D 持久性: 事务一旦被提交，则对数据库中的改变是持久化的。接下来即使数据库发生故障也不应该对其有任何影响

## 事务的隔离级别
> + 脏读：一个事务读到了另外一个事务暂未提交的数据
> + 不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对），简单的来说，就是读取到了其他事务已经提交了的数据(同一条记录两次不同)
> + 幻读：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(一批数据整体与前面的查询结果不同)

# spring如何实现事务
> + Spring的事务管理机制实现的原理，就是通过这样一个动态代理对所有需要事务管理的Bean进行加载，并根据配置在invoke方法中对当前调用的 方法名进行判定，并在method.invoke方法前后为其加上合适的事务管理代码，这样就实现了Spring式的事务管理。Spring中的AOP实 现更为复杂和灵活，不过基本原理是一致的。

## spring 的事务传播级别
> + PROPAGATION_REQUIRED 默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。

## spring AOP动态代理实现
> + jdk动态代理:https://blog.csdn.net/jiankunking/article/details/52143504

> + 通过实现 InvocationHandler 接口创建自己的调用处理器；
> + 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；
> + 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；
> + 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。
